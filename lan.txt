gradle


1) Project Level

build.gradle

buildscript{
	repositories {
		google()
		jcenter()
	}
	dependencies{
		classpath 'com.android.tools.build:gradle:3.0.0'
	}
}

allprojects {
	repositories{
		google()
		jcenter()
		mavenCentral()
		maven { url "http://dkeode" }
	}
}


2) Modul level

apply plugin 'com.android.application' //for all android application
apply plugin 'com.android.library' //for library


android {
	compileSdkVersion 27 //ne mores uporabiti fetures visje od te
	buildToolsVersion "26.0.2" verzija compilerja (optional)
	defaultConfigs {
		applicationId "si.mil.pero"
		minSdkVersion 21
		targetSdkVersion 27 max api level za katero si stestiral aplikacijo
	}
}

dependencies {
	implementation fileTree(dir: 'libs', include ['*.jar'])
	implementation 'com.android.support:appcompat-v7'
}


3) settings.gradle // tukaj dodaÅ¡ vse module

include ':app'

------------------------------------
gradlew //shell skripta - wrepper

gradle.settings //where it looks what to build

gradlew build
gradlew clean build


gradlew clean //cleans build folder

gradlew test //run tests


gradlew assamble

app/build/output/apk

gradlew lint
app/build/reports


---------
own file:

burek.gradle

ext{
	minSdkVersion 44
}

apply from: 'burek.gradle' //v project.gradle

rootProject.minSdkVersion
oz
"$rootProject.minSdkVersion" //znotraj string se uporabi $


---------------
Add task

task addDate() {
	...
}

gradle.taskGraph.whenReady {
	addDate
}

DEX files (Dalvik executables)
--------------------

settings.gradle

pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
    includeBuild("../neki")
}

dependencyResolutionManagement {
	repositories {
        google()
        mavenCentral()
    }
    includeBuild("../neki")
}

rootProject="nameOfproject"

include ':app'
include ':mylibrary'


-----------------------------------
jitpack.io //for publishing library

1) upload to githib

2) go to jitpack and past url of git repo

3) that is that



-------------------------------------------
JNI - Java native Interface
-------------------------------------------

*.so - shared lib
*.a  - static lib
JNI - interface where Java and C/C++ can talk to one another.
ABI - application Binary Interface (armv7, ...)
Android.mk - file describing the native library, including name, flags, linked libraries, and source files
Application.mk - 



jni
- Android.mk
- Application.mk
- keys.c


-----------
Android.mk:
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := keys
LOCAL_SRC_FILES := keys.c

include $(BUILD_SHARED_LIBRARY)

---------
Application.mk
APP_ABI := all

-------------
MainActivity.java

static {
    System.loadLibrary("keys");
}


----------
Gradle

android {
    .....
    buildTypes {
        .....
    }
    externalNativeBuild {
        ndkBuild {
            path 'src/main/jni/Android.mk'
        }
    }
}
--
or
--

./ndk-buils
/Users/blazoblak/Library/Android/sdk/ndk/27.0.12077973

./ndk-build -C /Users/blazoblak/Documents/work/SomeArrMaker/app/src/main/jni //do not forget -C
//Creates folder libs where you rename it to:
"jniLibs"


-------------------------------------------
-------------------------------------------
dotnet

dotnet new sln

dotnet new classlib

dotnet sln add PrimeService/PrimeService.csproj

mkdir PrimeService.Tests && cd PrimeService.Tests //make new dir and move to it
dotnet new nunit // add unittest

dotnet add reference ../PrimeService/PrimeService.csproj

dotnet sln add ./PrimeService.Tests/PrimeService.Tests.csproj


-------------------------------------------
C#
-------------------------------------------

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator

private async Task GetData(){ //Task == void
	
}

---------------
Operator ??=

// if a is null then assign 0 to a and add a to the list
numbers.Add(a ??= 0);


---------------
LINQ

var numCount = numbers.Count(n => n is > 3 and < 7);

---------------
Tasks:
---------------
Task t1 = new Task(() =>
{
    Console.WriteLine("Hello, World!");
    Console.WriteLine("Hello, World!");
    Console.WriteLine("Hello, World!");
});
t1.Start();
t1.Wait();
Console.WriteLine($"Rs:{2+3}");

--
Task taskA = Task.Run( () => Console.WriteLine("Hello from taskA."));

// Output a message from the calling thread.
Console.WriteLine($"Hello from thread '{Thread.CurrentThread.Name}'.");
taskA.Wait();
---
Task[] taskArray = new Task[10];
- adding work to tasks

Task.WaitAll(taskArray);

----
var outer = Task.Factory.StartNew(() => work());
-----
Task[] tasks = new Task[3]
{
    Task.Factory.StartNew(() => MethodA()),
    Task.Factory.StartNew(() => MethodB()),
    Task.Factory.StartNew(() => MethodC())
};

//Block until all tasks complete.
Task.WaitAll(tasks);

------------
Action:
------------

Action<int, String> print = (a, b) =>
{
    Console.WriteLine("Hello, World!");
};
print.Invoke(1, string.Empty);

------------
Funct
------------
Func<int, float, float> calculate = (a, b) =>
{
    return a + b;
};

------------
Cancalation token
------------

var ctx = new CancellationTokenSource();
var token = ctx.Token;


if (token.IsCancellationRequested)
{
    Console.WriteLine("Cancelled");
    break;
}

ctx.Cancel(); //canceling token

------------
async / await
------------

public async Task<string> GetStuff(){
	
	return "stuff";
}

string d = await GetStuff();

------
async Task Stuff1() {}
async Task Stuff2() {}

var tasks = new List<Task>() { Stuff1(), Stuff2() };

await Task.WhenAll(tasks);  //first executes first method then second


await Task.Factory.StartNew(Stuff1).ContinueWith((t)=>Stuff2());




------------
Extentions
------------

public record Person(string FirstName, string LastName);



public record Person
{
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
};

------
public readonly record struct Point(double X, double Y, double Z);

public record struct Point
{
    public double X { get; init; }
    public double Y { get; init; }
    public double Z { get; init; }
}


-------------------------------------------
C 
-------------------------------------------

#include

#include<conio.h>
#include<stdio.h>
#include <stdlib.h>


char arr[10];
char *pa = arr; //first field is address


*(pa + 3) = 'A'; //fourth element is now A


int sub(int a, int b){return a+b;}

--------------------
pointer to function:

int(*mp)(int, int);
mp = &add;

int res = mp(3, 5);
printf("%d\n", res);

------------------
struct Person{
    char name[10];
    int age;
};


struct person p;
struct person *pp = &p;


strcpy(p.name, "test"); // use .
p.age = 23;



strcpy(p->name, "test"); //use ->
p->age = 23;

------------------
#define ANDROID_FONT_PATH "/system/fonts"
-----------


-----------
typedef:
-----------

typedef struct 
{
    int i;
    char k;
} elem;

elem user;

-----------
malloc, calloc, free
-----------

int *ptr = (int *)malloc(20);

int *ptr = (int *)malloc(sizeof(int) * 5);


// Checking if failed or pass
if (ptr == NULL) {
    printf("Allocation Failed");
    exit(0);
}

--------
calloc()
--------
//The calloc() (stands for contiguous allocation) function is similar to malloc(), 
but it initializes the allocated memory to zero. It is used when you need memory with default zero values. 

int *ptr = (int *)calloc(5, sizeof(int));

--------
realloc()
--------
function is used to resize a previously allocated memory block.

int *ptr = (int *)malloc(5 * sizeof(int));

// Resize the memory block to hold 10 integers
ptr = (int *)realloc(ptr, 10 * sizeof(int));

// Check for allocation failure
if (ptr == NULL) {
    printf("Memory Reallocation Failed");
    exit(0);
}






