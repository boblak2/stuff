gradle


1) Project Level

build.gradle

buildscript{
	repositories {
		google()
		jcenter()
	}
	dependencies{
		classpath 'com.android.tools.build:gradle:3.0.0'
	}
}

allprojects {
	repositories{
		google()
		jcenter()
		mavenCentral()
		maven { url "http://dkeode" }
	}
}


2) Modul level

apply plugin 'com.android.application' //for all android application
apply plugin 'com.android.library' //for library


android {
	compileSdkVersion 27 //ne mores uporabiti fetures visje od te
	buildToolsVersion "26.0.2" verzija compilerja (optional)
	defaultConfigs {
		applicationId "si.mil.pero"
		minSdkVersion 21
		targetSdkVersion 27 max api level za katero si stestiral aplikacijo
	}
}

dependencies {
	implementation fileTree(dir: 'libs', include ['*.jar'])
	implementation 'com.android.support:appcompat-v7'
}


3) settings.gradle // tukaj dodaš vse module

include ':app'

------------------------------------
gradlew //shell skripta - wrepper

gradle.settings //where it looks what to build

gradlew build
gradlew clean build


gradlew clean //cleans build folder

gradlew test //run tests


gradlew assamble

app/build/output/apk

gradlew lint
app/build/reports


---------
own file:

burek.gradle

ext{
	minSdkVersion 44
}

apply from: 'burek.gradle' //v project.gradle

rootProject.minSdkVersion
oz
"$rootProject.minSdkVersion" //znotraj string se uporabi $


---------------
Add task

task addDate() {
	...
}

gradle.taskGraph.whenReady {
	addDate
}

DEX files (Dalvik executables)
--------------------

settings.gradle

pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
    includeBuild("../neki")
}

dependencyResolutionManagement {
	repositories {
        google()
        mavenCentral()
    }
    includeBuild("../neki")
}

rootProject="nameOfproject"

include ':app'
include ':mylibrary'


-----------------------------------
jitpack.io //for publishing library

1) upload to githib

2) go to jitpack and past url of git repo

3) that is that



-------------------------------------------
JNI - Java native Interface
-------------------------------------------

*.so - shared lib
*.a  - static lib
JNI - interface where Java and C/C++ can talk to one another.
ABI - application Binary Interface (armv7, ...)
Android.mk - file describing the native library, including name, flags, linked libraries, and source files
Application.mk - 



jni
- Android.mk
- Application.mk
- keys.c


-----------
Android.mk:
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := keys
LOCAL_SRC_FILES := keys.c

include $(BUILD_SHARED_LIBRARY)

---------
Application.mk
APP_ABI := all

-------------
MainActivity.java

static {
    System.loadLibrary("keys");
}


----------
Gradle

android {
    .....
    buildTypes {
        .....
    }
    externalNativeBuild {
        ndkBuild {
            path 'src/main/jni/Android.mk'
        }
    }
}
--
or
--

./ndk-buils
/Users/blazoblak/Library/Android/sdk/ndk/27.0.12077973

./ndk-build -C /Users/blazoblak/Documents/work/SomeArrMaker/app/src/main/jni //do not forget -C
//Creates folder libs where you rename it to:
"jniLibs"


Uri
android.resource:///  //for uri in assets
file:///              //for uri in your local storage
content://com.android.providers.media.documents/document/image%3A00038484 //for sharing
data://text/plain;charset=utf-8,hello%20world. //the uri itself holds the data


https://www.youtube.com/watch?v=IVHZpTyVOxU

-------------------------------------------
-------------------------------------------
dotnet
-------------------------------------------

dotnet new sln

dotnet new classlib

dotnet sln add PrimeService/PrimeService.csproj

mkdir PrimeService.Tests && cd PrimeService.Tests //make new dir and move to it
dotnet new nunit // add unittest

dotnet add reference ../PrimeService/PrimeService.csproj

dotnet sln add ./PrimeService.Tests/PrimeService.Tests.csproj


-------------------------------------------
C#
-------------------------------------------

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator

private async Task GetData(){ //Task == void
	
}

---------------
Operator ??=

// if a is null then assign 0 to a and add a to the list
numbers.Add(a ??= 0);


---------------
LINQ

var numCount = numbers.Count(n => n is > 3 and < 7);

---------------
Tasks:
---------------
Task t1 = new Task(() =>
{
    Console.WriteLine("Hello, World!");
    Console.WriteLine("Hello, World!");
    Console.WriteLine("Hello, World!");
});
t1.Start();
t1.Wait();
Console.WriteLine($"Rs:{2+3}");

--
Task taskA = Task.Run( () => Console.WriteLine("Hello from taskA."));

// Output a message from the calling thread.
Console.WriteLine($"Hello from thread '{Thread.CurrentThread.Name}'.");
taskA.Wait();
---
Task[] taskArray = new Task[10];
- adding work to tasks

Task.WaitAll(taskArray);

----
var outer = Task.Factory.StartNew(() => work());
-----
Task[] tasks = new Task[3]
{
    Task.Factory.StartNew(() => MethodA()),
    Task.Factory.StartNew(() => MethodB()),
    Task.Factory.StartNew(() => MethodC())
};

//Block until all tasks complete.
Task.WaitAll(tasks);

------------
Action:
------------

Action<int, String> print = (a, b) =>
{
    Console.WriteLine("Hello, World!");
};
print.Invoke(1, string.Empty);

------------
Funct
------------
Func<int, float, float> calculate = (a, b) =>
{
    return a + b;
};

------------
Cancalation token
------------

var ctx = new CancellationTokenSource();
var token = ctx.Token;


if (token.IsCancellationRequested)
{
    Console.WriteLine("Cancelled");
    break;
}

ctx.Cancel(); //canceling token

------------
async / await
------------

public async Task<string> GetStuff(){
	
	return "stuff";
}

string d = await GetStuff();

------
async Task Stuff1() {}
async Task Stuff2() {}

var tasks = new List<Task>() { Stuff1(), Stuff2() };

await Task.WhenAll(tasks);  //first executes first method then second


await Task.Factory.StartNew(Stuff1).ContinueWith((t)=>Stuff2());




------------
Records
------------

public record Person(string FirstName, string LastName);



public record Person
{
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
};

------
public readonly record struct Point(double X, double Y, double Z);

public record struct Point
{
    public double X { get; init; }
    public double Y { get; init; }
    public double Z { get; init; }
}

------------
Extentions
------------
TODO:



------------
gRPC
------------
- google Remote Procedure Call framework

 can run in any environment

- connect services

- mostly works like REST APIs

- it has a few standards to follow

- most important standards is Interface definition language (IDL) 
which is a common language both programs have to use to talk to each other.
 By default, gRPC uses protocol buffer (a.k.a. protobuf) as IDL.

- gRPC uses HTTP/2 for the RPC calls.


------------------------------------
Dependency Injection - DI
------------------------------------

public Test(IBurek burek, ILogger log) //DI - thrue constructor

Microsoft.Extentions.Hosting //nuget for DI

-----------------
IHost host = Host.CreateDefaultBuilder()
    .ConfigureServices(services =>
    {
        services.AddTransient<Work>();
    })
    .Build();

IBurek burek = host.Services.GetRequiredService<Work>();
--------------------


services.AddTransient<IBurek, Burek>(); //Vsakič druga instanca
services.AddSingleton<IBurek, Burek>(); //Vedno ista instanca
services.AddScoped<IBurek, Burek>(); //Instanca je narejena 1x per scope and the reused in scope.

Scope = container

using var firstScope = host-Services.CreateScope();


IServiceScopeFactory sf = ...

usinf var scope = sf.CreateScope();
scope.Serviceprovider.GetRequiredService<IBurek>();

Recomendation: EntetyFramework should work with Scoped lifetime.


.Add() //adds everytime
.TryAdd() //adds if none exists


DI vs ServiceLocator

ServiceLocator:
burek = Locator.getService<IBurek>();

------------------------------------
Stratagy patrn
------------------------------------

Use interfaces

IBurek food = new Mesni();
IBurek foo2 = new Sirov();

-------------------------------------------
C ANSI
-------------------------------------------

#include

#include<conio.h>
#include<stdio.h>
#include <stdlib.h>


char arr[10];
char *pa = arr; //first field is address


*(pa + 3) = 'A'; //fourth element is now A


int sub(int a, int b){return a+b;}

--------------------
pointer to function:

int(*mp)(int, int);
mp = &add;

int res = mp(3, 5);
printf("%d\n", res);

------------------
struct Person{
    char name[10];
    int age;
};


struct person p;
struct person *pp = &p;


strcpy(p.name, "test"); // use .
p.age = 23;



strcpy(p->name, "test"); //use ->
p->age = 23;

------------------
#define ANDROID_FONT_PATH "/system/fonts"
-----------


-----------
typedef:
-----------

typedef struct 
{
    int i;
    char k;
} elem;

elem user;

-----------
malloc, calloc, free
-----------

int *ptr = (int *)malloc(20);

int *ptr = (int *)malloc(sizeof(int) * 5);


// Checking if failed or pass
if (ptr == NULL) {
    printf("Allocation Failed");
    exit(0);
}

--------
calloc()
--------
//The calloc() (stands for contiguous allocation) function is similar to malloc(), 
but it initializes the allocated memory to zero. It is used when you need memory with default zero values. 

int *ptr = (int *)calloc(5, sizeof(int));

--------
realloc()
--------
function is used to resize a previously allocated memory block.

int *ptr = (int *)malloc(5 * sizeof(int));

// Resize the memory block to hold 10 integers
ptr = (int *)realloc(ptr, 10 * sizeof(int));

// Check for allocation failure
if (ptr == NULL) {
    printf("Memory Reallocation Failed");
    exit(0);
}

--------
extern
--------

C uses undividual units when compiling, with "exter" we tell compiler that we are using it here,
but it is decleared somewhere else.

Example:

stdio.h
int errno; //not extern

myCFile1.c
#include <stdio.h>

myCFile2.c
#include <stdio.h>


if myCFile1.o and myCFile2.o are linked, each of the c files have separate copies of errno.
This is a problem as the same errno is supposed to be available in all linked files.  //ful bed :(


stdio.h
extern int errno;

stdio.c
int errno;



myCFile1.c
#include <stdio.h>

myCFile2.c
#include <stdio.h>


Now if both myCFile1.o and MyCFile2.o are linked by the linker they will 
both point to the same errno. Thus, solving the implementation with extern. :) //yeah

----------------
Static variable
----------------

It is initialized only once and is not destroyed when the function returns.

Static variables are generally declared inside functions.

outside functions - Global scope

Global static variables have their scope limited to the file they are defined in (internal linkage). 
It means that they cannot be accessed outside the current translation unit (C source file).


-----------------
Flags
-----------------

gcc -o name main.c

-Wall //Enable every warning

-Werror //Convert warnings into errors

-l //Link with a shared library
gcc main.c -o Hello -lpthread

-L //link the external libraries
gcc -L/home/user/LHB -o main.c Results -lLHB

-g //include debug information

-std=c99 //standard











